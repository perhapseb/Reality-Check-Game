<!-- Reality Check Game -->
<!-- NMA 322 -->

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Reality Check</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <link rel="stylesheet" href="style.css" />
</head>

<body>

    <!-- really basic, only a main div, then a character img, and a bg img -->
    <div id="game-area">

        <div id="fade-overlay"></div>

        <div id="main-menu">
            <img id="menu-bg" src="Assets/MainMenu.png" alt="">
            <button id="play-btn">Begin</button>
        </div>

        <img id="bg-layer" src="" alt="background"> <!-- this the background!!!! -->
        <img id="char-layer" src="" alt="character"> <!-- this the char!!!!!! -->

        <!-- this is where the dialog is -->
        <div id="dialog-box">
            <div id="passage-text"></div>
            <div id="choices"></div>
            <div id="error"></div>
        </div>
    </div>

    <!-- and all the codeeeeeee -->
    <script>

        // just loads the twee file
        async function LoadDialogFile() {
            const res = await fetch("dialog.twee");
            if (!res.ok) throw new Error("Could not load dialog.twee");
            return await res.text();
        }

        // so we dont include the options in the displayed text using regex
        function ExtractDialogText(text) {
            const lines = text.split(/\r?\n/);
            const keep = [];
            const linkOnlyLine = /^\s*(\[\[.+?\]\]\s*)+$/; // one or more [[...]] and nothing else

            for (const line of lines) {
                // if the line is ONLY the dialog options (like [[Hello]] or [[Hello]][[Bye]]) we dont include it
                if (linkOnlyLine.test(line)) continue;
                keep.push(line);
            }

            let body = keep.join("\n");
            body = body.replace(/\[\[(.+?)(->|<-)(.+?)\]\]/g, (_, p1) => p1.trim()).replace(/\[\[(.+?)\]\]/g, (_, p1) => p1.trim());
            return body.trim();
        }

        // from the twee file. we convert it to text, and we run this function to get the dialog and the choices too
        function parseTwee(tweeText) {
            const lines = tweeText.split(/\r?\n/);
            const story = { passages: {}, start: null };
            let current = null;
            let buffer = [];
            function finishPassage() {
                if (!current) return;
                current.text = buffer.join("\n").trim();
                current.links = GetDialogChoices(current.text);
                story.passages[current.name] = current;
                if (!story.start) story.start = current.name;
                buffer = [];
            }
            for (let line of lines) {
                const m = /^::\s*(.+)$/.exec(line);
                if (m) {
                    finishPassage();
                    let header = m[1].trim();
                    let name = header
                        .replace(/\{.*?\}/g, "")
                        .replace(/\[.*?\]/g, "")
                        .trim();

                    current = { name, text: "", links: [] };
                } else {
                    buffer.push(line);
                }
            }
            finishPassage();
            const sd = /"start":\s*"(.+?)"/.exec(tweeText);
            if (sd) story.start = sd[1];
            return story;
        }

        // extracts the dialog choices from the text
        function GetDialogChoices(text) {
            const links = [];
            const re = /\[\[(.+?)\]\]/g;
            let match;

            while (match = re.exec(text)) {
                const inner = match[1];
                let label, target;

                if (inner.includes("->")) {
                    [label, target] = inner.split("->").map(s => s.trim());
                } else if (inner.includes("<-")) {
                    [target, label] = inner.split("<-").map(s => s.trim());
                } else {
                    label = target = inner.trim();
                }

                links.push({ label, target });
            }
            return links;
        }

        function getSpeaker(text) {
            const colonIndex = text.indexOf(":");
            if (colonIndex === -1) return null;
            return text.slice(0, colonIndex).trim();
        }


        // typewriter effect for text display
        function typeText(element, text, speed = 25) {
            return new Promise(resolve => {
                element.textContent = "";

                // basically we only want the text AFTER the colon to be typed out
                // so that the char name shows up instantly
                const colonIndex = text.indexOf(":");

                let prefix = "";
                let toType = text;

                // if there is a colon, we split the text
                if (colonIndex !== -1) {
                    prefix = text.slice(0, colonIndex + 1);
                    toType = text.slice(colonIndex + 1).trimStart();
                    element.textContent = prefix + "\n";
                }

                let i = 0;

                // then this is the loop that types each character out
                function step() {
                    if (i < toType.length) {
                        const ch = toType[i++];
                        element.textContent += ch;

                        let delay = speed;

                        // if blank, instantly type
                        if (ch === " ") {
                            delay = 0;
                        }
                        // if punctuation, add a bit more delay for pauses
                        else if (/[.,!?;:â€¦]/.test(ch)) {
                            delay = speed + 100;
                        }

                        setTimeout(step, delay);
                    } else {
                        resolve();
                    }
                }

                step();
            });
        }

        function fadeInBlack() {
            return new Promise(resolve => {
                const f = document.getElementById("fade-overlay");
                f.style.opacity = "1";
                setTimeout(resolve, 800); // must match CSS transition
            });
        }

        function fadeOutBlack() {
            return new Promise(resolve => {
                const f = document.getElementById("fade-overlay");
                f.style.opacity = "0";
                setTimeout(resolve, 800);
            });
        }

        function showMainMenu() {
            document.getElementById("char-layer").style.display = "none";
            document.getElementById("dialog-box").style.display = "none";
            document.getElementById("main-menu").style.display = "flex";
            document.getElementById("play-btn").onclick = startGame;
        }

        async function startGame() {

            await fadeInBlack();

            document.getElementById("main-menu").style.display = "none";
            document.getElementById("char-layer").style.display = "block";
            document.getElementById("dialog-box").style.display = "block";

            RenderPage(storyCache, storyCache.start);
            await fadeOutBlack();
        }

        let lastSpeaker = "startedstory";   // empty so first run fades in


        // this is what we call each time we want to show a new message
        // handles the bg, char images, message text, and choices
        async function RenderPage(story, name) {

            const p = story.passages[name];
            const text = document.getElementById("passage-text");
            const choices = document.getElementById("choices");
            const error = document.getElementById("error");

            if (!p) {

                text.textContent = "";
                choices.innerHTML = "";

                // error.textContent = `Could not find the message for dialog option "${name}". Make sure there are no trailing/leading spaces within the dialog choices in the .twee file.`;

                const tryBtn = document.createElement("button");
                tryBtn.classList.add("try-again");
                tryBtn.textContent = "The End. Restart?";
                tryBtn.onclick = () => RenderPage(story, story.start);
                choices.appendChild(tryBtn);
                lastSpeaker = "startedstory"

                return;
            }

            choices.innerHTML = ""; // clear previous choice buttons for the last page
            error.textContent = "";

            const shown = ExtractDialogText(p.text);

            // bg and char image changing
            function setBackground(url) {
                document.getElementById("bg-layer").src = url;

                if (url === "") {
                    document.getElementById("bg-layer").style.display = "none";
                } else {
                    document.getElementById("bg-layer").style.display = "block";
                }
            }

            function setCharacter(url) {
                document.getElementById("char-layer").src = url;
                if (url === "") {
                    document.getElementById("char-layer").style.display = "none";
                } else {
                    document.getElementById("char-layer").style.display = "block";
                }
            }

            // im just using blank images i made in photoshop for now. when we get the art assets this will look much nicer :)
            if (shown.includes("Harbourfront")) {
                setBackground("./Assets/Backgrounds/Scene1.png");
            }

            if (shown.includes("Imperial")) {
                setBackground("./Assets/Backgrounds/Scene2.png");
            }

            if (shown.includes("TRSM")) {
                setBackground("./Assets/Backgrounds/Scene3.png");
            }

            // basically searching the dialogue text for a name. for example we can do "Olivia:" and show the specific image for the Olivia character
            if (shown.includes("Olivia:")) {
                if (shown.includes("Uhh") || (shown.includes("creep")) || (shown.includes("wrong"))) {
                    setCharacter("./Assets/Olivia/Olivia_Disgusted.png");
                } else if (shown.includes("brushing")) {
                    setCharacter("./Assets/Olivia/Olivia_Smiling.png");
                } else {
                    setCharacter("./Assets/Olivia/Olivia_Neutral.png");
                }
            } else {
                if (shown.includes("Claire:")) {
                    if (shown.includes("Uhh") || (shown.includes("awkward"))) {
                        setCharacter("./Assets/Claire/Claire_Awkward.png");
                    } else if (shown.includes("...") || (shown.includes("wrong"))) {
                        setCharacter("./Assets/Claire/Claire_Disgusted.png");
                    } else {
                        setCharacter("./Assets/Claire/Claire_Neutral.png");
                    }
                } else {
                    if (shown.includes("Camilla:")) {
                        if (shown.includes("Uhh") || (shown.includes("wrong"))) {
                            setCharacter("./Assets/Camilla/Camilla_Awkward.png");
                        }
                        else {
                            setCharacter("./Assets/Camilla/Camilla_Neutral.png");
                        }
                    } else {
                        setCharacter("");
                    }
                }
            }

            if (shown.includes("play good")) {
                setCharacter("./Assets/Claire/Claire_Awkward.png");
            }

            await fadeOutBlack();

            await typeText(text, shown); // we wait for the typewriter effect to finish before we show the choices

            // when there are no more choices, u show a button that resets the game
            if (p.links.length === 0) {
                const tryBtn = document.createElement("button");
                tryBtn.classList.add("try-again");
                tryBtn.textContent = "reset back to start";
                tryBtn.onclick = () => RenderPage(story, story.start);
                choices.appendChild(tryBtn);
                setBackground("");
                setCharacter("");
                lastSpeaker = "startedstory"
                return;
            }

            // create buttons for each choices
            p.links.forEach(link => {
                const btn = document.createElement("button");
                btn.classList.add("choice-btn");
                btn.textContent = link.label;
                btn.onclick = async () => {
                    text.textContent = "";
                    choices.innerHTML = ""; // clear previous choice buttons for the last page
                    await fadeInBlack();
                    RenderPage(story, link.target);
                    await fadeOutBlack();
                };
                choices.appendChild(btn);
            });
        }

        // run this only once at start
        let storyCache = null;

        (async () => {
            const twee = await LoadDialogFile();
            storyCache = parseTwee(twee);

            // Show main menu instead of starting immediately
            showMainMenu();
        })();

    </script>
</body>

</html>